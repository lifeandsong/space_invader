
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #00ff00;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        canvas {
            border: 2px solid #00ff00;
            background: #000;
        }
        
        #score {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        #gameOver {
            font-size: 32px;
            color: #ff0000;
            margin-top: 20px;
            display: none;
        }
        
        #instructions {
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">Score: 0 | Stage: 1 | Lives: 3</div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="gameOver">GAME OVER<br>Press R to Restart</div>
        <div id="gameComplete" style="font-size: 32px; color: #00ff00; margin-top: 20px; display: none;">
            CONGRATULATIONS!<br>YOU SAVED THE GALAXY!<br>Press R to Play Again
        </div>
        <div id="newRecord" style="font-size: 24px; color: #ffff00; margin-top: 20px; display: none;">
            NEW HIGH SCORE!<br>
            Enter your name (max 10 chars):<br>
            <input type="text" id="playerName" maxlength="10" style="font-size: 20px; text-align: center; margin: 10px;">
            <br><button id="submitScore" style="font-size: 16px; padding: 5px 15px;">Submit</button>
        </div>
        <div id="rankings" style="font-size: 18px; color: #00ffff; margin-top: 20px;">
            <div style="font-size: 24px; margin-bottom: 10px;">üèÜ HIGH SCORES üèÜ</div>
            <div id="rankingList"></div>
        </div>
        <div id="instructions" style="margin-top: 20px; font-size: 14px; color: #888;">
            Use ARROW KEYS to move ‚Ä¢ SPACEBAR to shoot ‚Ä¢ R to restart
        </div>
        <div id="startScreen" style="font-size: 24px; color: #00ff00; margin-top: 20px;">
            SPACE INVADERS<br><br>
            Press R to Start Game
        </div>
    </div>

    <script>
        // Game canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const gameOverElement = document.getElementById('gameOver');
        const gameCompleteElement = document.getElementById('gameComplete');
        const startScreenElement = document.getElementById('startScreen');
        const newRecordElement = document.getElementById('newRecord');
        const playerNameInput = document.getElementById('playerName');
        const submitScoreButton = document.getElementById('submitScore');
        const rankingListElement = document.getElementById('rankingList');

        // Game state
        let gameRunning = false; // Start with game not running
        let gameStarted = false; // Track if game has started
        let score = 0;
        let keys = {};
        let ufoSpawnTimer = Math.random() * 1000 + 500; // Random spawn time
        let currentStage = 1;
        let isGameComplete = false;
        let playerLives = 3;
        let invulnerabilityTimer = 0;
        let previewStage = Math.floor(Math.random() * 4) + 1; // Random stage 1-4 for preview

        // Audio context for sound effects
        let audioContext;
        let ufoSoundInterval;

        // Ranking system
        let rankings = [];
        let isNewRecord = false;

        // Player object
        const player = {
            x: canvas.width / 2 - 25,
            y: canvas.height - 60,
            width: 50,
            height: 30,
            speed: 5,
            color: '#00ff00'
        };

        // Arrays for game objects
        let bullets = [];
        let invaders = [];
        let invaderBullets = [];
        let barriers = [];
        let ufo = null;
        let ufoBombs = [];

        // Bullet class
        class Bullet {
            constructor(x, y, speed, color = '#ffff00') {
                this.x = x;
                this.y = y;
                this.width = 4;
                this.height = 10;
                this.speed = speed;
                this.color = color;
            }

            update() {
                this.y += this.speed;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            isOffScreen() {
                return this.y < 0 || this.y > canvas.height;
            }
        }

        // Invader class
        class Invader {
            constructor(x, y, stage = 1) {
                this.x = x;
                this.y = y;
                this.stage = stage;
                this.direction = 1;
                this.shootTimer = Math.random() * 200 + 100;
                this.animationFrame = 0; // For leg animation
                this.animationTimer = 0;
                
                // Stage-specific properties
                switch(stage) {
                    case 1:
                        this.width = 40;
                        this.height = 30;
                        this.speed = 1;
                        this.color = '#ff0000';
                        this.health = 1;
                        this.shootRate = 0.001;
                        this.legCount = 2;
                        break;
                    case 2:
                        this.width = 50;
                        this.height = 40;
                        this.speed = 1.5;
                        this.color = '#ff8800';
                        this.health = 2;
                        this.shootRate = 0.002;
                        this.legCount = 3;
                        break;
                    case 3:
                        this.width = 80;
                        this.height = 60;
                        this.speed = 0.8;
                        this.color = '#8800ff';
                        this.health = 5;
                        this.shootRate = 0.005;
                        this.legCount = 4;
                        break;
                    case 4:
                        this.width = 120;
                        this.height = 100;
                        this.speed = 0.5;
                        this.color = '#ff0088';
                        this.health = 10;
                        this.shootRate = 0.008;
                        this.legCount = 4;
                        break;
                }
                this.maxHealth = this.health;
            }

            update() {
                this.x += this.speed * this.direction;
                
                // Update leg animation
                this.animationTimer++;
                if (this.animationTimer >= 15) { // Change animation every 15 frames
                    this.animationFrame = (this.animationFrame + 1) % 2;
                    this.animationTimer = 0;
                    
                    // Play move sound occasionally
                    if (Math.random() < 0.1) {
                        playInvaderMoveSound(this.stage);
                    }
                }
                
                // Shooting logic - more frequent for higher stages
                this.shootTimer--;
                if (this.shootTimer <= 0 && Math.random() < this.shootRate) {
                    // Stage 3 and 4 shoot multiple bullets
                    if (this.stage >= 3) {
                        for (let i = 0; i < 3; i++) {
                            invaderBullets.push(new Bullet(
                                this.x + this.width/2 + (i-1) * 20, 
                                this.y + this.height, 
                                3, 
                                '#ff0000'
                            ));
                        }
                    } else {
                        invaderBullets.push(new Bullet(this.x + this.width/2, this.y + this.height, 3, '#ff0000'));
                    }
                    this.shootTimer = Math.random() * 300 + 200;
                }
            }

            draw() {
                // Health-based color intensity
                const healthRatio = this.health / this.maxHealth;
                let drawColor = this.color;
                
                if (healthRatio < 1) {
                    // Darken color as health decreases
                    const r = parseInt(this.color.substr(1, 2), 16);
                    const g = parseInt(this.color.substr(3, 2), 16);
                    const b = parseInt(this.color.substr(5, 2), 16);
                    drawColor = `rgb(${Math.floor(r * healthRatio)}, ${Math.floor(g * healthRatio)}, ${Math.floor(b * healthRatio)})`;
                }
                
                // Draw main body
                ctx.fillStyle = drawColor;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Stage-specific appearance
                switch(this.stage) {
                    case 1:
                        // Simple invader
                        ctx.fillStyle = '#000';
                        ctx.fillRect(this.x + 5, this.y + 5, 8, 8);
                        ctx.fillRect(this.x + 27, this.y + 5, 8, 8);
                        ctx.fillRect(this.x + 15, this.y + 15, 10, 5);
                        break;
                    case 2:
                        // Medium invader with more details
                        ctx.fillStyle = '#000';
                        ctx.fillRect(this.x + 8, this.y + 8, 10, 10);
                        ctx.fillRect(this.x + 32, this.y + 8, 10, 10);
                        ctx.fillRect(this.x + 18, this.y + 20, 14, 8);
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(this.x + 20, this.y + 25, 10, 5);
                        break;
                    case 3:
                        // Large invader
                        ctx.fillStyle = '#000';
                        ctx.fillRect(this.x + 15, this.y + 15, 15, 15);
                        ctx.fillRect(this.x + 50, this.y + 15, 15, 15);
                        ctx.fillRect(this.x + 30, this.y + 35, 20, 10);
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(this.x + 10, this.y + 10, 8, 8);
                        ctx.fillRect(this.x + 62, this.y + 10, 8, 8);
                        break;
                    case 4:
                        // Boss monster
                        ctx.fillStyle = '#000';
                        ctx.fillRect(this.x + 20, this.y + 20, 20, 20);
                        ctx.fillRect(this.x + 80, this.y + 20, 20, 20);
                        ctx.fillRect(this.x + 45, this.y + 50, 30, 15);
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(this.x + 15, this.y + 15, 12, 12);
                        ctx.fillRect(this.x + 93, this.y + 15, 12, 12);
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(this.x + 50, this.y + 70, 20, 10);
                        break;
                }
                
                // Draw animated legs
                this.drawLegs();
                
                // Health bar for stages 3 and 4
                if (this.stage >= 3) {
                    const barWidth = this.width;
                    const barHeight = 4;
                    const barY = this.y - 8;
                    
                    // Background
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x, barY, barWidth, barHeight);
                    
                    // Health
                    ctx.fillStyle = healthRatio > 0.5 ? '#00ff00' : healthRatio > 0.25 ? '#ffff00' : '#ff0000';
                    ctx.fillRect(this.x, barY, barWidth * healthRatio, barHeight);
                }
            }

            drawLegs() {
                ctx.fillStyle = this.color;
                const legWidth = Math.max(3, Math.floor(this.width / 15));
                const legHeight = Math.max(8, Math.floor(this.height / 4));
                const legSpacing = this.width / (this.legCount + 1);
                
                for (let i = 0; i < this.legCount; i++) {
                    const legX = this.x + legSpacing * (i + 1) - legWidth / 2;
                    let legY = this.y + this.height;
                    
                    // Animate legs - alternate between two positions
                    if (this.animationFrame === 0) {
                        // Normal position
                        ctx.fillRect(legX, legY, legWidth, legHeight);
                        // Add foot
                        ctx.fillRect(legX - 2, legY + legHeight, legWidth + 4, 3);
                    } else {
                        // Slightly moved position for walking animation
                        const offset = (i % 2 === 0) ? 2 : -2;
                        ctx.fillRect(legX + offset, legY, legWidth, legHeight);
                        // Add foot
                        ctx.fillRect(legX + offset - 2, legY + legHeight, legWidth + 4, 3);
                    }
                }
            }

            takeDamage() {
                this.health--;
                return this.health <= 0;
            }
        }

        // Barrier class
        class Barrier {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 80;
                this.height = 60;
                this.blockSize = 4;
                this.color = '#00ff00';
                
                // Create barrier structure as a 2D array (20x15 blocks)
                this.blocks = [];
                this.initializeBlocks();
            }

            initializeBlocks() {
                const rows = this.height / this.blockSize;
                const cols = this.width / this.blockSize;
                
                // Create barrier shape pattern
                const pattern = [
                    "11111111111111111111",
                    "11111111111111111111",
                    "11111111111111111111",
                    "11111111111111111111",
                    "11111111111111111111",
                    "11111111111111111111",
                    "11111111111111111111",
                    "11111111111111111111",
                    "11111111111111111111",
                    "11111000000000001111",
                    "11110000000000011111",
                    "11100000000000111111",
                    "11000000000001111111",
                    "10000000000011111111",
                    "00000000000111111111"
                ];

                for (let row = 0; row < rows; row++) {
                    this.blocks[row] = [];
                    for (let col = 0; col < cols; col++) {
                        if (row < pattern.length && col < pattern[row].length) {
                            this.blocks[row][col] = pattern[row][col] === '1';
                        } else {
                            this.blocks[row][col] = false;
                        }
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                for (let row = 0; row < this.blocks.length; row++) {
                    for (let col = 0; col < this.blocks[row].length; col++) {
                        if (this.blocks[row][col]) {
                            ctx.fillRect(
                                this.x + col * this.blockSize,
                                this.y + row * this.blockSize,
                                this.blockSize,
                                this.blockSize
                            );
                        }
                    }
                }
            }

            checkCollision(bulletX, bulletY, bulletWidth, bulletHeight) {
                // Check if bullet overlaps with barrier bounds
                if (bulletX + bulletWidth < this.x || bulletX > this.x + this.width ||
                    bulletY + bulletHeight < this.y || bulletY > this.y + this.height) {
                    return false;
                }

                // Check collision with individual blocks
                const startCol = Math.max(0, Math.floor((bulletX - this.x) / this.blockSize));
                const endCol = Math.min(this.blocks[0].length - 1, Math.floor((bulletX + bulletWidth - this.x) / this.blockSize));
                const startRow = Math.max(0, Math.floor((bulletY - this.y) / this.blockSize));
                const endRow = Math.min(this.blocks.length - 1, Math.floor((bulletY + bulletHeight - this.y) / this.blockSize));

                for (let row = startRow; row <= endRow; row++) {
                    for (let col = startCol; col <= endCol; col++) {
                        if (this.blocks[row][col]) {
                            // Destroy blocks in a small area around the hit
                            this.destroyBlocks(col, row, 2);
                            return true;
                        }
                    }
                }
                return false;
            }

            destroyBlocks(centerCol, centerRow, radius) {
                for (let row = Math.max(0, centerRow - radius); 
                     row <= Math.min(this.blocks.length - 1, centerRow + radius); row++) {
                    for (let col = Math.max(0, centerCol - radius); 
                         col <= Math.min(this.blocks[0].length - 1, centerCol + radius); col++) {
                        // Create circular destruction pattern
                        const distance = Math.sqrt((col - centerCol) ** 2 + (row - centerRow) ** 2);
                        if (distance <= radius) {
                            this.blocks[row][col] = false;
                        }
                    }
                }
            }
        }

        // UFO Bomb class
        class UFOBomb {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 12;
                this.height = 20;
                this.speed = 2;
                this.color = '#ff8800';
            }

            update() {
                this.y += this.speed;
            }

            draw() {
                // Draw large bomb
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Add some detail to make it look like a bomb
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(this.x + 2, this.y + 2, this.width - 4, this.height - 4);
                ctx.fillStyle = '#ff6600';
                ctx.fillRect(this.x + 4, this.y + 4, this.width - 8, this.height - 8);
            }

            isOffScreen() {
                return this.y > canvas.height;
            }
        }

        // UFO class
        class UFO {
            constructor() {
                this.width = 60;
                this.height = 25;
                this.speed = 2;
                this.color = '#ff00ff';
                this.bombTimer = Math.random() * 200 + 100;
                
                // Randomly choose direction and starting position
                if (Math.random() < 0.5) {
                    // Move left to right
                    this.x = -this.width;
                    this.direction = 1;
                } else {
                    // Move right to left
                    this.x = canvas.width;
                    this.direction = -1;
                }
                this.y = 30;
            }

            update() {
                this.x += this.speed * this.direction;
                
                // Drop bombs occasionally
                this.bombTimer--;
                if (this.bombTimer <= 0 && Math.random() < 0.02) {
                    ufoBombs.push(new UFOBomb(this.x + this.width/2 - 6, this.y + this.height));
                    this.bombTimer = Math.random() * 150 + 100;
                }
            }

            draw() {
                // Draw UFO body
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x + 10, this.y + 10, this.width - 20, this.height - 10);
                
                // Draw UFO dome
                ctx.fillStyle = '#ff66ff';
                ctx.fillRect(this.x + 15, this.y, this.width - 30, 15);
                
                // Draw UFO base/rim
                ctx.fillStyle = '#cc00cc';
                ctx.fillRect(this.x, this.y + 15, this.width, 10);
                
                // Add some lights
                ctx.fillStyle = '#ffff00';
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(this.x + 8 + i * 12, this.y + 18, 4, 4);
                }
            }

            isOffScreen() {
                return (this.direction === 1 && this.x > canvas.width) || 
                       (this.direction === -1 && this.x < -this.width);
            }
        }

        // Initialize invaders based on stage (for preview or actual game)
        function createInvaders(stage = currentStage) {
            invaders = [];
            
            switch(stage) {
                case 1:
                    // 3 rows of small invaders
                    for (let row = 0; row < 3; row++) {
                        for (let col = 0; col < 10; col++) {
                            invaders.push(new Invader(col * 60 + 50, row * 50 + 50, 1));
                        }
                    }
                    break;
                case 2:
                    // 4 rows of medium invaders
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 8; col++) {
                            invaders.push(new Invader(col * 80 + 60, row * 60 + 50, 2));
                        }
                    }
                    break;
                case 3:
                    // 4 big invaders in a 2x2 formation
                    for (let row = 0; row < 2; row++) {
                        for (let col = 0; col < 2; col++) {
                            invaders.push(new Invader(col * 200 + 200, row * 100 + 80, 3));
                        }
                    }
                    break;
                case 4:
                    // 1 giant boss monster
                    invaders.push(new Invader(canvas.width/2 - 60, 100, 4));
                    break;
            }
        }

        // Initialize barriers
        function createBarriers() {
            barriers = [];
            const barrierCount = 4;
            const barrierSpacing = canvas.width / (barrierCount + 1);
            
            for (let i = 0; i < barrierCount; i++) {
                const x = barrierSpacing * (i + 1) - 40; // Center the barrier
                const y = canvas.height - 200; // Position between player and invaders
                barriers.push(new Barrier(x, y));
            }
        }

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameRunning) {
                    bullets.push(new Bullet(player.x + player.width/2, player.y, -7));
                    playPlayerShootSound();
                }
            }
            
            if (e.code === 'KeyR') {
                if (!gameStarted) {
                    startGame();
                } else if (!isNewRecord) {
                    restartGame();
                }
            }
        });

        // Handle score submission
        submitScoreButton.addEventListener('click', submitScore);
        playerNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitScore();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Initialize audio context
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Sound generation functions
        function playPlayerShootSound() {
            initAudio();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playInvaderMoveSound(stage) {
            initAudio();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Different frequencies for different stages
            const frequencies = [150, 180, 120, 100];
            oscillator.frequency.setValueAtTime(frequencies[stage - 1], audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.05);
        }

        function playInvaderHitSound(stage) {
            initAudio();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Different hit sounds for different stages
            const frequencies = [400, 350, 300, 250];
            oscillator.frequency.setValueAtTime(frequencies[stage - 1], audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(frequencies[stage - 1] * 0.5, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        function playInvaderDeathSound(stage) {
            initAudio();
            
            // Create explosion-like sound with multiple oscillators
            for (let i = 0; i < 3; i++) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Different death sounds for different stages
                const baseFreqs = [600, 500, 400, 300];
                const freq = baseFreqs[stage - 1] + (i * 100);
                
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(freq * 0.1, audioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime + i * 0.05);
                oscillator.stop(audioContext.currentTime + 0.3);
            }
        }

        function startUFOSound() {
            if (ufoSoundInterval) return;
            
            initAudio();
            ufoSoundInterval = setInterval(() => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(330, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(220, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime + 0.2);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            }, 400);
        }

        function stopUFOSound() {
            if (ufoSoundInterval) {
                clearInterval(ufoSoundInterval);
                ufoSoundInterval = null;
            }
        }

        function playUFODestroySound() {
            initAudio();
            
            // Create a satisfying UFO destruction sound
            for (let i = 0; i < 4; i++) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                const freq = 800 - (i * 150);
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(freq * 0.2, audioContext.currentTime + 0.4);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                
                oscillator.start(audioContext.currentTime + i * 0.1);
                oscillator.stop(audioContext.currentTime + 0.4);
            }
        }

        function playStageClearSound() {
            initAudio();
            
            // Happy stage clear melody
            const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
            
            notes.forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.4, audioContext.currentTime + index * 0.2);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + index * 0.2 + 0.3);
                
                oscillator.start(audioContext.currentTime + index * 0.2);
                oscillator.stop(audioContext.currentTime + index * 0.2 + 0.3);
            });
        }

        function playGameCompleteSound() {
            initAudio();
            
            // Victory fanfare
            const melody = [
                {freq: 523, time: 0},    // C5
                {freq: 659, time: 0.3},  // E5
                {freq: 784, time: 0.6},  // G5
                {freq: 1047, time: 0.9}, // C6
                {freq: 784, time: 1.2},  // G5
                {freq: 1047, time: 1.5}, // C6
                {freq: 1319, time: 1.8}, // E6
                {freq: 1568, time: 2.1}  // G6
            ];
            
            melody.forEach(note => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(note.freq, audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime + note.time);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + note.time + 0.4);
                
                oscillator.start(audioContext.currentTime + note.time);
                oscillator.stop(audioContext.currentTime + note.time + 0.4);
            });
        }

        function playGameOverSound() {
            initAudio();
            
            // Sad game over sound - descending notes
            const notes = [523, 466, 415, 349, 294]; // C5 down to D4
            
            notes.forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(freq * 0.8, audioContext.currentTime + 0.5);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime + index * 0.3);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + index * 0.3 + 0.5);
                
                oscillator.start(audioContext.currentTime + index * 0.3);
                oscillator.stop(audioContext.currentTime + index * 0.3 + 0.5);
            });
        }

        // Ranking system functions
        function loadRankings() {
            const saved = localStorage.getItem('spaceInvadersRankings');
            if (saved) {
                rankings = JSON.parse(saved);
            } else {
                // Initialize with default rankings
                rankings = [
                    {name: "ALIEN", score: 1000},
                    {name: "INVADER", score: 500},
                    {name: "UFO", score: 100}
                ];
            }
            displayRankings();
        }

        function saveRankings() {
            localStorage.setItem('spaceInvadersRankings', JSON.stringify(rankings));
        }

        function displayRankings() {
            let html = '';
            for (let i = 0; i < Math.min(3, rankings.length); i++) {
                const rank = i + 1;
                const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : 'ü•â';
                html += `<div style="margin: 5px 0;">${medal} ${rank}. ${rankings[i].name} - ${rankings[i].score}</div>`;
            }
            rankingListElement.innerHTML = html;
        }

        function checkNewRecord(finalScore) {
            // Check if score qualifies for top 3
            if (rankings.length < 3 || finalScore > rankings[2].score) {
                return true;
            }
            return false;
        }

        function submitScore() {
            const playerName = playerNameInput.value.trim() || "ANONYMOUS";
            const newEntry = {name: playerName.toUpperCase(), score: score};
            
            // Add new score and sort
            rankings.push(newEntry);
            rankings.sort((a, b) => b.score - a.score);
            
            // Keep only top 3
            rankings = rankings.slice(0, 3);
            
            // Save and display
            saveRankings();
            displayRankings();
            
            // Hide new record input
            newRecordElement.style.display = 'none';
            isNewRecord = false;
            
            // Show appropriate completion message
            if (isGameComplete) {
                gameCompleteElement.style.display = 'block';
            } else {
                gameOverElement.style.display = 'block';
            }
        }

        // Update player position
        function updatePlayer() {
            if (keys['ArrowLeft'] && player.x > 0) {
                player.x -= player.speed;
            }
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) {
                player.x += player.speed;
            }
            
            // Update invulnerability timer
            if (invulnerabilityTimer > 0) {
                invulnerabilityTimer--;
            }
        }

        // Draw player
        function drawPlayer() {
            // Flash player when invulnerable
            if (invulnerabilityTimer > 0 && Math.floor(invulnerabilityTimer / 5) % 2 === 0) {
                return; // Skip drawing to create flashing effect
            }
            
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            // Draw player cannon
            ctx.fillRect(player.x + player.width/2 - 3, player.y - 10, 6, 10);
        }

        // Update bullets
        function updateBullets() {
            // Update player bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].update();
                if (bullets[i].isOffScreen()) {
                    bullets.splice(i, 1);
                }
            }
            
            // Update invader bullets
            for (let i = invaderBullets.length - 1; i >= 0; i--) {
                invaderBullets[i].update();
                if (invaderBullets[i].isOffScreen()) {
                    invaderBullets.splice(i, 1);
                }
            }
            
            // Update UFO bombs
            for (let i = ufoBombs.length - 1; i >= 0; i--) {
                ufoBombs[i].update();
                if (ufoBombs[i].isOffScreen()) {
                    ufoBombs.splice(i, 1);
                }
            }
        }

        // Update invaders
        function updateInvaders() {
            let changeDirection = false;
            
            // Check if any invader hits the edge
            for (let invader of invaders) {
                if (invader.x <= 0 || invader.x >= canvas.width - invader.width) {
                    changeDirection = true;
                    break;
                }
            }
            
            // Move invaders down and change direction
            if (changeDirection) {
                for (let invader of invaders) {
                    invader.direction *= -1;
                    invader.y += 20;
                }
            }
            
            // Update each invader
            for (let invader of invaders) {
                invader.update();
            }
        }

        // Update UFO
        function updateUFO() {
            // Spawn UFO occasionally
            ufoSpawnTimer--;
            if (ufoSpawnTimer <= 0 && !ufo && Math.random() < 0.01) {
                ufo = new UFO();
                ufoSpawnTimer = Math.random() * 1500 + 1000; // Reset timer
                startUFOSound(); // Start UFO sound
            }
            
            // Update existing UFO
            if (ufo) {
                ufo.update();
                if (ufo.isOffScreen()) {
                    ufo = null;
                    stopUFOSound(); // Stop UFO sound
                }
            }
        }

        // Check collisions
        function checkCollisions() {
            // Player bullets vs invaders
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = invaders.length - 1; j >= 0; j--) {
                    if (bullets[i] && invaders[j] &&
                        bullets[i].x < invaders[j].x + invaders[j].width &&
                        bullets[i].x + bullets[i].width > invaders[j].x &&
                        bullets[i].y < invaders[j].y + invaders[j].height &&
                        bullets[i].y + bullets[i].height > invaders[j].y) {
                        
                        bullets.splice(i, 1);
                        
                        // Check if invader is destroyed
                        if (invaders[j].takeDamage()) {
                            playInvaderDeathSound(invaders[j].stage);
                            invaders.splice(j, 1);
                            score += 10 * currentStage; // More points for higher stages
                        } else {
                            playInvaderHitSound(invaders[j].stage);
                        }
                        
                        updateScoreDisplay();
                        break;
                    }
                }
            }
            
            // Player bullets vs UFO
            if (ufo) {
                for (let i = bullets.length - 1; i >= 0; i--) {
                    if (bullets[i] &&
                        bullets[i].x < ufo.x + ufo.width &&
                        bullets[i].x + bullets[i].width > ufo.x &&
                        bullets[i].y < ufo.y + ufo.height &&
                        bullets[i].y + bullets[i].height > ufo.y) {
                        
                        bullets.splice(i, 1);
                        ufo = null;
                        stopUFOSound(); // Stop UFO sound when destroyed
                        playUFODestroySound(); // Play UFO destruction sound
                        score += 100; // Bonus points for UFO
                        updateScoreDisplay();
                        break;
                    }
                }
            }
            
            // Player bullets vs barriers
            for (let i = bullets.length - 1; i >= 0; i--) {
                if (bullets[i]) {
                    for (let barrier of barriers) {
                        if (barrier.checkCollision(bullets[i].x, bullets[i].y, bullets[i].width, bullets[i].height)) {
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            
            // Invader bullets vs barriers
            for (let i = invaderBullets.length - 1; i >= 0; i--) {
                if (invaderBullets[i]) {
                    for (let barrier of barriers) {
                        if (barrier.checkCollision(invaderBullets[i].x, invaderBullets[i].y, invaderBullets[i].width, invaderBullets[i].height)) {
                            invaderBullets.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            
            // UFO bombs vs barriers
            for (let i = ufoBombs.length - 1; i >= 0; i--) {
                if (ufoBombs[i]) {
                    for (let barrier of barriers) {
                        if (barrier.checkCollision(ufoBombs[i].x, ufoBombs[i].y, ufoBombs[i].width, ufoBombs[i].height)) {
                            // UFO bombs destroy more blocks
                            const centerCol = Math.floor((ufoBombs[i].x + ufoBombs[i].width/2 - barrier.x) / barrier.blockSize);
                            const centerRow = Math.floor((ufoBombs[i].y + ufoBombs[i].height/2 - barrier.y) / barrier.blockSize);
                            barrier.destroyBlocks(centerCol, centerRow, 4); // Larger destruction radius
                            ufoBombs.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            
            // Invader bullets vs player
            for (let i = invaderBullets.length - 1; i >= 0; i--) {
                if (invulnerabilityTimer <= 0 && // Only check collision if not invulnerable
                    invaderBullets[i].x < player.x + player.width &&
                    invaderBullets[i].x + invaderBullets[i].width > player.x &&
                    invaderBullets[i].y < player.y + player.height &&
                    invaderBullets[i].y + invaderBullets[i].height > player.y) {
                    
                    invaderBullets.splice(i, 1);
                    playerHit();
                    return;
                }
            }
            
            // UFO bombs vs player
            for (let i = ufoBombs.length - 1; i >= 0; i--) {
                if (invulnerabilityTimer <= 0 && // Only check collision if not invulnerable
                    ufoBombs[i].x < player.x + player.width &&
                    ufoBombs[i].x + ufoBombs[i].width > player.x &&
                    ufoBombs[i].y < player.y + player.height &&
                    ufoBombs[i].y + ufoBombs[i].height > player.y) {
                    
                    ufoBombs.splice(i, 1);
                    playerHit();
                    return;
                }
            }
            
            // Check if invaders reached player
            for (let invader of invaders) {
                if (invader.y + invader.height >= player.y) {
                    gameOver();
                    return;
                }
            }
        }

        // Update score display
        function updateScoreDisplay() {
            scoreElement.textContent = `Score: ${score} | Stage: ${currentStage} | Lives: ${playerLives}`;
        }

        // Player hit function
        function playerHit() {
            playerLives--;
            invulnerabilityTimer = 120; // 2 seconds of invulnerability at 60fps
            updateScoreDisplay();
            
            if (playerLives <= 0) {
                gameOver();
            }
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            playGameOverSound(); // Play sad game over sound
            
            // Check for new record
            if (checkNewRecord(score)) {
                isNewRecord = true;
                newRecordElement.style.display = 'block';
                playerNameInput.value = '';
                playerNameInput.focus();
            } else {
                gameOverElement.style.display = 'block';
            }
        }

        // Game complete
        function gameComplete() {
            gameRunning = false;
            isGameComplete = true;
            playGameCompleteSound(); // Play victory fanfare
            
            // Check for new record
            if (checkNewRecord(score)) {
                isNewRecord = true;
                newRecordElement.style.display = 'block';
                playerNameInput.value = '';
                playerNameInput.focus();
            } else {
                gameCompleteElement.style.display = 'block';
            }
        }

        // Start game function
        function startGame() {
            initAudio(); // Initialize audio when game starts
            gameStarted = true;
            gameRunning = true;
            startScreenElement.style.display = 'none';
            
            // Reset to actual game state
            currentStage = 1;
            score = 0;
            playerLives = 3;
            invulnerabilityTimer = 0;
            updateScoreDisplay();
            
            // Reset player position
            player.x = canvas.width / 2 - 25;
            player.y = canvas.height - 60;
            
            // Clear arrays
            bullets = [];
            invaderBullets = [];
            ufoBombs = [];
            ufo = null;
            stopUFOSound();
            ufoSpawnTimer = Math.random() * 1000 + 500;
            
            // Create actual game invaders and barriers
            createInvaders();
            createBarriers();
        }

        // Restart game
        function restartGame() {
            gameRunning = true;
            isGameComplete = false;
            isNewRecord = false;
            score = 0;
            currentStage = 1;
            playerLives = 3;
            invulnerabilityTimer = 0;
            updateScoreDisplay();
            gameOverElement.style.display = 'none';
            gameCompleteElement.style.display = 'none';
            newRecordElement.style.display = 'none';
            
            // Reset player position
            player.x = canvas.width / 2 - 25;
            player.y = canvas.height - 60;
            
            // Clear arrays
            bullets = [];
            invaderBullets = [];
            ufoBombs = [];
            ufo = null;
            stopUFOSound();
            ufoSpawnTimer = Math.random() * 1000 + 500;
            
            // Recreate invaders and barriers
            createInvaders();
            createBarriers();
        }

        // Draw everything
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars background
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 50; i++) {
                let x = (i * 37) % canvas.width;
                let y = (i * 23) % canvas.height;
                ctx.fillRect(x, y, 1, 1);
            }
            
            if (!gameStarted) {
                // Draw preview screen
                drawPreviewScreen();
            } else {
                // Draw actual game
                drawPlayer();
                
                bullets.forEach(bullet => bullet.draw());
                invaderBullets.forEach(bullet => bullet.draw());
                ufoBombs.forEach(bomb => bomb.draw());
                invaders.forEach(invader => invader.draw());
                barriers.forEach(barrier => barrier.draw());
                
                // Draw UFO if it exists
                if (ufo) {
                    ufo.draw();
                }
                
                // Draw lives indicator
                ctx.fillStyle = '#00ff00';
                ctx.font = '16px Courier New';
                for (let i = 0; i < playerLives; i++) {
                    ctx.fillText('‚ô¶', 20 + i * 25, canvas.height - 20);
                }
            }
        }

        // Draw preview screen
        function drawPreviewScreen() {
            // Draw preview invaders (static, no movement)
            const previewInvaders = [];
            
            switch(previewStage) {
                case 1:
                    for (let row = 0; row < 3; row++) {
                        for (let col = 0; col < 10; col++) {
                            previewInvaders.push(new Invader(col * 60 + 50, row * 50 + 100, 1));
                        }
                    }
                    break;
                case 2:
                    for (let row = 0; row < 4; row++) {
                        for (let col = 0; col < 8; col++) {
                            previewInvaders.push(new Invader(col * 80 + 60, row * 60 + 80, 2));
                        }
                    }
                    break;
                case 3:
                    for (let row = 0; row < 2; row++) {
                        for (let col = 0; col < 2; col++) {
                            previewInvaders.push(new Invader(col * 200 + 200, row * 100 + 120, 3));
                        }
                    }
                    break;
                case 4:
                    previewInvaders.push(new Invader(canvas.width/2 - 60, 150, 4));
                    break;
            }
            
            // Draw preview invaders
            previewInvaders.forEach(invader => invader.draw());
            
            // Draw preview barriers
            const previewBarriers = [];
            const barrierCount = 4;
            const barrierSpacing = canvas.width / (barrierCount + 1);
            
            for (let i = 0; i < barrierCount; i++) {
                const x = barrierSpacing * (i + 1) - 40;
                const y = canvas.height - 200;
                previewBarriers.push(new Barrier(x, y));
            }
            
            previewBarriers.forEach(barrier => barrier.draw());
            
            // Draw preview player
            ctx.fillStyle = '#00ff00';
            const previewPlayerX = canvas.width / 2 - 25;
            const previewPlayerY = canvas.height - 60;
            ctx.fillRect(previewPlayerX, previewPlayerY, 50, 30);
            ctx.fillRect(previewPlayerX + 22, previewPlayerY - 10, 6, 10);
            
            // Draw stage title
            ctx.fillStyle = '#ffff00';
            ctx.font = '32px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`STAGE ${previewStage} PREVIEW`, canvas.width/2, 50);
            ctx.textAlign = 'left';
        }

        // Main game loop
        function gameLoop() {
            if (gameRunning) {
                updatePlayer();
                updateBullets();
                updateInvaders();
                updateUFO();
                checkCollisions();
                
                // Check win condition
                if (invaders.length === 0) {
                    if (currentStage < 4) {
                        // Advance to next stage
                        playStageClearSound(); // Play stage clear sound
                        currentStage++;
                        createInvaders();
                        createBarriers(); // Reset barriers for new stage
                        updateScoreDisplay();
                    } else {
                        // Game complete!
                        gameComplete();
                    }
                }
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Initialize and start game
        loadRankings(); // Load rankings on startup
        createInvaders(previewStage); // Create preview invaders
        createBarriers(); // Create preview barriers
        gameLoop();
    </script>
</body>
</html>
